# 5. 클로저

## 5-1. 클로저의 의미 및 원리 이해

### 클로저

**“A closure is the combination of a function and the lexical environment within which that function was declared.”** (MDN)

→ 어떤 함수에서 선언한 변수를 참조하는 내부 함수에서만 발생하는 현상

```jsx
var outer = function() {
  var a = 1;
  var inner = function() {
    return ++a;
  };
  return inner;
};
var outer2 = outer(); // outer의 실행 컨텍스트 종료
console.log(outer2()); // 2
console.log(outer2()); // 3
```

- outer2 변수는 outer()의 실행 결과인 inner 함수를 참조
- outer의 실행 컨텍스트가 종료된 후 inner 함수를 호출할 때 inner함수의 outerEnvironmentReference인 outer 함수의 LexicalEnvironment에 접근하여 outer에서 선언한 변수 a를 가져옴.
    
    → 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않기 때문
    
    <aside>
    💡 스펙상으로는 선언 당시의 LexicalEnvironment 전부를 GC하지 않도록 돼 있으나, 2019년 기준으로 크롬이나 Node.js 등에서 사용 중인 V8 엔진의 경우 내부 함수에서 실제로 사용하는 변수만 남겨두고 나머지는 GC하도록 최적화돼 있습니다.
    
    </aside>
    
    → 이처럼 함수의 실행 컨텍스트가 종료된 후에도 LexicalEnvironment가 가비지 컬렉터의 수집 대상에서 제외되는 경우는 지역 변수를 참조하는 내부 함수가 외부로 전달된 경우가 유일
    
    즉, “어떤 함수에서 선언한 변수를 참조하는 내부 함수에서만 발생하는 현상”이란 “외부 함수의 LexicalEnvironment가 가비지 컬렉팅되지 않는 현상”
    

클로저란 어떤 함수 A에서 선언한 변수 a를 참조하는 내부 함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상을 말한다.

### 내부 함수를 외부로 전달하는 경우

- return을 통해 내부 함수를 전달하는 경우
- 별도의 외부객체인 window 메서드에 전달할 콜백 함수 내부에서 지역변수 참조
    
    ```jsx
    // (1) setInterval/setTimeout
    (function() {
      var a = 0;
      var intervalId = null;
      var inner = function() {
        if (++a >= 10) {
          clearInterval(intervalId);
        }
        console.log(a);
      };
      intervalId = setInterval(inner, 1000);
    })();
    ```
    
- 별도의 외부 객체인 DOM의 메서드에 등록할 handler 함수 내부에서 지역 변수 참조
    
    ```jsx
    // (2) eventListener
    (function() {
      var count = 0;
      var button = document.createElement('button');
      button.innerText = 'click';
      button.addEventListener('click', function() {
        console.log(++count, 'times clicked');
      });
      document.body.appendChild(button);
    })();
    ```
    

## 5-2. 클로저와 메모리 관리

- 메모리 누수: 개발자의 의도와 달리 어떤 값의 참조 카운트가 0이 되지 않아 GC의 수거 대상이 되지 않는 경우
- 클로저는 의도적으로 함수의 지역 변수를 메모리를 소모하도록 함으로써 발생하므로, 그 필요성이 사라진 시점에는 더는 메모리를 소모하지 않게 만들어준다.
- 참조 카운트를 0으로 만드는 방법: 식별자에 참조형이 아닌 기본형 데이터(null이나 undefined)를 할당하기

```jsx
// (1) return에 의한 클로저의 메모리 해제
var outer = (function() {
  var a = 1;
  var inner = function() {
    return ++a;
  };
  return inner;
})();
console.log(outer());
console.log(outer());
outer = null; // outer 식별자의 inner 함수 참조를 끊음
```

```jsx
// (2) setInterval에 의한 클로저의 메모리 해제
(function() {
  var a = 0;
  var intervalId = null;
  var inner = function() {
    if (++a >= 10) {
      clearInterval(intervalId);
      inner = null; // inner 식별자의 함수 참조를 끊음
    }
    console.log(a);
  };
  intervalId = setInterval(inner, 1000);
})();
```

```jsx
// (3) eventListener에 의한 클로저의 메모리 해제
(function() {
  var count = 0;
  var button = document.createElement('button');
  button.innerText = 'click';

  var clickHandler = function() {
    console.log(++count, 'times clicked');
    if (count >= 10) {
      button.removeEventListener('click', clickHandler);
      clickHandler = null; // clickHandler 식별자의 함수 참조를 끊음
    }
  };
  button.addEventListener('click', clickHandler);
  document.body.appendChild(button);
})();
```

## 5-3. 클로저 활용 사례

### 5-3-1. 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때

```jsx
var fruits = ['apple', 'banana', 'peach'];
var $ul = document.createElement('ul');

var alertFruit = function(fruit) {
  alert('your choice is ' + fruit);
};
fruits.forEach(function(fruit) {
  var $li = document.createElement('li');
  $li.innerText = fruit;
  $li.addEventListener('click', alertFruit); // [object MouseEvent]
  $ul.appendChild($li);
});
document.body.appendChild($ul);
alertFruit(fruits[1]);
```

- 콜백 함수의 인자에 대한 제어권을 addEventListener가 가진 상태이며, addEventListener는 콜백 함수를 호출할 때 첫 번째 인자에 ‘이벤트 객체’를 주입하기 때문

```jsx
fruits.forEach(function(fruit) {
  var $li = document.createElement('li');
  $li.innerText = fruit;
  $li.addEventListener('click', alertFruit.bind(null, fruit)); //
  $ul.appendChild($li);
});
```

- bind 메서드를 활용해 해결이 가능하지만, 이렇게 하면 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점, 함수 내부에서의 this가 원래의 그것과 달라지는 점을 감안해야 한다.
    
    <aside>
    💡 bind 메서드의 첫 번째 인자가 새로 바인딩할 this인데, 이 값을 생략할 수 없기 때문에 일반적으로 원래의 this를 유지하도록 할 수 없는 경우가 많습니다. 또한 위 예제에서는 두 번째 인자에 이벤트 객체가 넘어올 것입니다.
    
    </aside>
    

```jsx
var fruits = ['apple', 'banana', 'peach'];
var $ul = document.createElement('ul');

var alertFruitBuilder = function(fruit) {
  return function() {
    alert('your choice is ' + fruit);
  };
};
fruits.forEach(function(fruit) {
  var $li = document.createElement('li');
  $li.innerText = fruit;
  $li.addEventListener('click', alertFruitBuilder(fruit));
  $ul.appendChild($li);
});
document.body.appendChild($ul);
```

- 고차함수 이용: 함수를 인자로 받거나 함수를 리턴하는 함수
    
    클릭 이벤트가 발생하면 alertFruitBuilder 안의 익명 함수의 실행 컨텍스트가 열리면서 alertFruitBuilder의 인자로 넘어온 fruit를 outerEnvironmentReference에 의해 참조할 수 있다. alertFruitBuilder의 실행 결과로 반환된 함수에는 클로저가 존재.
    

### 5-3-2. 접근 권한 제어(정보 은닉)

### 5-3-3. 부분 적용 함수

### 5-3-4. 커링 함수

## 5-4. 정리
