# 콜백 함수

## 콜백 함수란?

* 콜백 함수란 다른 코드의 인자로 넘겨주는 함수
* 다른 함수나 메서드에게 인자를 넘겨줄 때 함수에 대한 __제어권__ 도 함께 위임하는 함수
    - _함수 X를 호출하면서 특정 조건일 때 함수 Y도 실행해 나에게 알려줘! 라는 요청과 위임권 주는 것_
* 콜백 함수를 위임받은 코드는 콜백 함수를 적절한 시점에 실행을 함


## 제어권 

* __호출 시점__
    ```javascript
        var count = 0;
        var cbFunc = function() {
            console.log(count);
            if (++count > 4) clearInterval(timer);
        };
        var timer = setInterval(cbFunc, 300);
        //timer 변수에는 setInterval의 ID 값이 담김

        /*실행 결과
        0 (0.3초)
        1 (0.6초)
        2 (0.9초)
        3 (1.2초)
        4 (1.5초)
        */
    ```
    - 위 함수에서 setInterval의 첫 번째 인자 cbFunc 함수가 콜백함수가 되고, 0.3초마다 자동으로 실행됨
    - cbFunc(콜백 함수) 내부에서는 count 값을 출력 > 1 증가 후 4보다 큰지 확인하고 > 만약 4보다 크다면 반복 실행을 종료!
    - 위 코드를 실행하면 setInterval이라는 다른 코드에 인자로 cbFunc함수를 넘겨주었으므로 제어권을 넘겨 받았고, 스스로의 판단에 따라 적절하게 함수를 실행함. 따라서 아까 언급을 했듯이 __콜백 함수의 제어권을 넘겨받은 함수/메서드 (setInterval)은 콜백 함수 호출 시점을 결정할 수 있게 되는 것임.__

* __인자__

    - __콜백 함수의 제어권을 넘겨받은 코드는 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대해서도 제어권을 가짐__

        ```javascript
            var newArr = [10, 20, 30].map(function (currentValue, index){ 
                console.log(currentValue, index);
                return currentValue + 5;
            }); //newArr 변수 선언, 우항의 결과 할당.

            console.log(newArr); //할당한 우항의 결과 보기

            /*실행 결과
            10 0
            20 1 
            30 2
            [15, 25, 35]*/
        ```
        - 배열 _[10, 20, 30]_ 에 map 메서드를 호출함<br>
            - map 메서드 실행 이후 _[15, 25, 35]_ 라는 새로운 배열 생성!
            - 새로운 배열은 newArr에 저장이 되어 출력 됨 <br><br>

        > 🤔 map 메서드란? 🤔<br>
          메서드의 대상이 되는 배열의 요소의 하나하나를 꺼내 콜백 함수 반복 호출하며, 이를 반영해 새로운 배열 생성하는 메서드 <br>
          _Array.prototype.map(callback[, thisArg])_ <br>
          _callbackL function(currentValue, index, array)_ <br>
          첫 번째 인자로 callback 함수를 받고, 두 번째 인자로 콜백 함수 내부에서 this로 인식할 대상 특정. (생략 시 전역 객체 바인딩)

        - 위에 코드에서 결국 map 메서드에 제어권을 넘겨주었다고 할 수 있음. (사용자가 콜백 함수를 호출하는 게 아니니깐) 이때, map 메서드에 들어갈 인자들의 순서를 바꾸게 된다면 우리가 원하는 값이 나오지 않음. 즉, __콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길지 결정하는 제어권을 가짐__

* __this__

    - 콜백 함수에서 기본적으로는 this가 전역 객체를 참조하지만 제어권을 넘겨받을 코드에서 콜백 함수에 this가 될 대상을 지정할 경우 해당 대상을 참조하게 됨

## 콜백 함수는 함수다

* 콜백 함수로 어떤 객체의 메서드를 전달해도 해당 메서드는 메서드로서 호출이 되는 것이 아니고 __함수로서 호출이 됨!__

    ```javascript
        var obj = {
            vals: [1,2,3],
            logValues: function(v, i){
                console.log(this, v, i);
            }
        };
        obj.logValues(1, 2);
        [4,5,6].forEach(obj.logValues);
    ```
    - obj 객체의 logValues는 메서드로 정이가 되었고, forEach 함수의 콜백 함수로서 메서드가 전달이 됨
    - 이때, this가 가리키는 객체 obj 메서드를 그대로 전달하지 않고, obj.logValues가 가리키는 함수만 전달을 한 것임. 따라서 이는 obj라는 객체와 연관성이 없어지는 것임! 그러므로 forEach에 의해 콜백이 함수로서 호출이 되고, 함수 내부에서 this는 전역 객체를 바라봄.

## 콜백 함수 내부의 this에 다른 값 바인딩하기

* 전통적인 방식
    - 다른 변수에 this를 담아 콜백 함수로 활용할 함수에서 this 대신 해당 변수를 사용하게 한 후 클로저를 만드는 방식을 활용했음

    👎 this를 실제로 사용하지도 않음 <br>
    👎 번거로운 방식!

* bind 메서드를 활용하는 방식
    - 전통적인 방식을 활용하는 것보다 훨씬 더 간편한 방식
    - this 관련 챕터를 참고할 것

## 콜백 지옥과 비동기 제어

* 콜백 지옥(callback hell)이란?

    - 콜백 함수를 익명 함수로 전달하는 과정이 계속 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상
    - 이벤트 처리나 서버 통신과 같이 비동기적인 작업을 수행할 때 이런 문제가 발생함 <br>
    👎 가독성이 좋지 않고, 코드 수정이 어려움

* 비동기(asynchronous)란?
    - 현재 실행 중인 코드가 완료된 후에야 다음 코드를 실행하는 동기(synchronous)의 반댓말로, __현재 실행 중인 코드의 완료 여부와는 상관없이 즉시 다음 코드로 넘어가는 형태__
    - 사용자의 개입이 있을 때 함수를 실행하도록 대기할 경우, 웹브라우저 자체가 아닌 별도의 대상에 무엇인가를 요청하고 응답이 왔을 때 함수를 실행하는 경우 등이 포함됨
    - _별도의 요청, 실행 대기, 보류_ 와 관련된 코드는 비동기적 코드라고 할 수 있음 <br>

* 콜백 지옥 해결하기!
    -  익명의 콜백 함수를 모두 기명함수로 전환하기 <br>
        👍 가독성을 높이는 하나의 방법 <br>
        👎 일회성 함수를 전부 변수에 할당하는 것은 코드명을 일일이 따라다녀야 하므로 헷갈리는 과정일 수도 있음 <br>> Promise, Generator 등이 ES6에 도입이 되었고, ES2017에는 async/await가 도입이 됨.