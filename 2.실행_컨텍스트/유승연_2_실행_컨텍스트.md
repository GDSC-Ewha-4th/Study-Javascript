
# 02  실행 컨텍스트

스택

큐

### 실행 컨텍스트

실행할 코드에 제공할 환경 정보들을 모아놓은 객체

전역 공간에서 자동으로 생성되는 전역 컨텍스트와 eval 및 함수 실행에 의한 컨텍스트 등이 있음

콜 스택에 환경 정보를 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서 보장

실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장

**실행 컨텍스트 객체가 활동화되는 시점에 수집하는 정보 세가지**

- `VariableEnvironment`
    - 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보. 선언 시점의 `LexicalEnvironment`의 스냅샷으로, **변경 사항은 반영되지 않음.**
    - `environmentRecord`,   `outerEnvironmentReference`로 구성
    
- `LexicalEnvironment`
    - 처음에는 `VariableEnvironment` 과 같지만 **변경 사항이 실시간으로 반영됨.**
    - `environmentRecord`,   `outerEnvironmentReference`로 구성
    
- `ThisBinding`
    - this 식별자가 바라봐야 할 대상 객체.
    

---

### `environmentRecord` 와 호이스팅

`environmentRecord` 에는 현재 컨텍스트와 관련된 코드의 식별자 정보 저장

매개변수 식별자, 선언한 함수, var로 선언된 변수의 식별자 등을 컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 순서대로 수집

변수 정보 수집을 모두 마지더라도 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태

**호이스팅**

끌어올리다, `environmentRecord`의 수집 과정을 추상화한 개념

변수는 선언부와 할당부를 나누어 선언부만 끌어올리는 반면 함수 선언은 함수 전체를 끌어올림

---

### 함수 선언문과 함수 표현식

함수를 새롭게 정의할 때 쓰이는 방식

- 함수 선언문
    - function 정의부만 존재하고 별도의 할당 명령이 없는 것
    - 반드시 함수명이 정의되어야 함
- 함수 표현식
    - 정의한 function을 별도의 변수에 할당하는 것
    - 함수명을 정의한 함수 표현식 : 기명 함수 표현식
    - 함수명을 정의하지 않은 표현식 : 익명 함수 표현식 (多)

```jsx
function a(){ /*...*/ }        //함수 선언문. 함수명 a가 변수명
a();   //실행됨

var b = function(){ /*...*/ }  //(익명) 함수 표현식. 변수명 b가 곧 함수명.
b();   //실행됨

var c = function d(){ /*...*/ } //기명 함수 표현식. 변수명은 c, 함수명은 d
c();   //실행됨
d();   //에러
```

**함수 선언문은 전체를 호이스팅, 함수 표현식은 변수 선언부만 호이스팅함**

함수 선언문으로 동일한 변수명에 서로 다른 값을 할당한 경우 나중에 할당한 값이 먼저 할당한 값을 덮어씌움 (오버라이드)

따라서 코드를 실해앟는 중에 실제로 호출되는 함수는 오직 마지막에 할당한 함수, 마지막에 선언된 함수 뿐

>> 상대적으로 함수 표현식이 안전하다

---

### 스코프, 스코프 체인, outerEnvironmentReference

`스코프`는 식별자에 대한 유효범위

식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것을 `스코프 체인`이라고 함

`outerEnvironmentReference`는 현재 호출된 함수가 선언될 당시의 `LexicalEnvironment`를 참조

여러 스코프에서 동일한 식별자를 선언한 경우에는 **무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능**



 전역 공간에서는 전역 스코프에서 생성된 변수에만 접근할 수 있고, outer 함수 내부에서는 outer 및 전역 스코프에서 생성된 변수에 접근할 수 있지만 inner 스코프 내부에서 생성된 변수에는 접근하지 못한다. inner 함수 내부에서는 inner, outer, 전역 스코프 모두에 접근할 수 있다.

**변수 은닉화**

식별자 a를 전역 공간과 inner 함수 내부에서 모두 선언했을 때, 

inner 함수 내부에서 a에 접근하려고 하면 무조건 스코프 체인 상의 첫 번째 인자, inner 스코프의 `LexicalEnvironment`부터 검색함. inner 스코프의 `LexicalEnvironment`에 a 식별자가 존재하므로 스코프 체인 검색을 더 진행하지 않고 즉시 a를 반환한다. 

**inner 함수 내부에서 a 변수를 선언했기 때문에 전역 공간에서 선언한 동일한 이름의 a변수에는 접근할 수 없음**

---

### 전역변수와 지역변수

전역 공간에서 선언한 변수는 전역변수, 함수 내부에서 선언한 변수는 지역변수

코드의 안전성을 위해 가급적 전역변수 사용을 최소화하는 것이 좋음

---

### This

실행 컨텍스트를 활성화하는 당시에 지정된 this가 저장됨

함수를 호출하는 방법에 따라 값이 달라지며, 지정되지 않은 경우 전역 객체가 저장됨

(3장에서 더 자세히)
